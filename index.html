<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="data:,">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Interactive Chess Board with Python Engine</title>
    
    <!-- Local Bootstrap CSS -->
    <link href="node_modules/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Local Chessboard CSS -->
    <link rel="stylesheet" href="css/chessboard-1.0.0.css">
    
    <style>
                #currentFen.status-value {
            /* Force text to wrap within container */
            word-wrap: break-word;
            word-break: break-all;
            white-space: normal;
            
            /* Set specific width and height */
            max-width: 350px;
            min-height: 48px;
            
            /* Add padding for better readability */
            padding: 8px;
            
            /* Make it scrollable if still too long */
            overflow-y: auto;
            
            /* Font styling */
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.3;
            
            /* Background and border */
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }

                .stored-analysis {
            background: #507ca8;
            border-radius: 8px;
            padding: 15px;
        }

        .analysis-header {
            border-bottom: 2px solid #000000;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .analysis-header h6 {
            margin: 0 0 8px 0;
            color: #ffffff;
        }

        .analysis-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .tag-badge {
            background: #28998a;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
        }

        .analysis-section {
            margin-bottom: 15px;
        }

        .analysis-section h6 {
            color: #495057;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .best-moves {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .best-move {
            background: white;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #29045a;
        }

        body {
            background: linear-gradient(135deg, #121214 0%, #0f3381 100%);
            font-family: 'Arial', sans-serif;
            padding: 20px;
            min-height: 100vh;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #2c3e50, #34495e);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }

        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content-area {
            display: flex;
            min-height: 600px;
        }

        .board-section {
            flex: 1;
            padding: 30px;
            background: #131d26;
        }
        .best-move-item {
            margin: 8px 0;
            padding: 8px;
            background: #f8f9fa;
            border-left: 3px solid #007bff;
            border-radius: 4px;
            font-family: monospace;
        }
        .engine-moves-section {
            border-left: 4px solid #28a745 !important;
        }

        .engine-move {
            display: inline-block;
            background: #47486e;
            color: white;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-family: monospace;
            font-size: 0.9em;
        }

        .engine-move:hover {
            background: #47486e;
            transform: scale(1.05);
        }


        .controls-section {
            width: 400px;
            padding: 30px;
            background: #41414a;
            border-left: 1px solid #dee2e6;
            overflow-y: auto;
        }

        .tab-navigation {
            display: flex;
            margin-bottom: 25px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .tab-btn {
            flex: 1;
            padding: 12px 20px;
            background: #6c757d;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .tab-btn.active {
            background: #007bff;
            transform: scale(1.05);
        }

        .tab-btn:hover {
            background: #0056b3;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .game-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 25px;
        }

        .btn-custom {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 500;
            transition: all 0.3s;
            cursor: pointer;
        }

        .btn-primary-custom {
            background: #2b2f58;
            color: white;
        }

        .btn-primary-custom:hover {
            background: #2e345b;
            transform: translateY(-2px);
        }

        .btn-secondary-custom {
            background: #6c757d;
            color: white;
        }

        .btn-secondary-custom:hover {
            background: #545b62;
        }

        .btn-success-custom {
            background: #1a2339;
            color: white;
        }

        .btn-success-custom:hover {
            background: #1d1b36;
        }

        .btn-danger-custom {
            background: #54151ba5;
            color: white;
        }

        .btn-danger-custom:hover {
            background: #9b0010a5;
        }

        .game-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
        }

        .game-info h5 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }

        .status-item {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }

        .status-label {
            font-weight: 600;
            color: #495057;
        }

        .status-value {
            color: #000000;
            font-family:'Courier New', Courier, monospace ;
        }

        .move-history {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            line-height: 1.6;
        }

        /* Board and Evaluation Container */
        .board-eval-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            width: 100%;
        }

        .board-top-section {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 30px;
        }

        .eval-bar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            flex-shrink: 0;
        }

        .eval-bar-container h6 {
            margin-bottom: 10px;
            color: #2c3e50;
            font-weight: 600;
        }


        /* Vertical Evaluation Bar */
        .evaluation-bar {
            width: 40px;
            height: 300px;
            background: #f0f0f0;
            border: 2px solid #333;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .eval-white {
            background: #ffffff;
            border-top: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.5s ease;
            height: 50%;
        }
        .eval-value {
            margin-top: 10px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            background: #212529;
            padding: 5px 10px;
            border-radius: 4px;
            min-width: 40px;
            text-align: center;
        }

        .eval-black {
            background: #333333;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.5s ease;
            height: 50%;
        }

        /* Circle indicators for possible moves */
        .move-indicator {
            position: relative;
        }

        .move-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.3);
            z-index: 10;
            pointer-events: none;
        }

        .capture-indicator {
            position: relative;
        }

        .capture-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: rgba(44, 29, 29, 0.7);
            border: 2px solid rgba(44, 29, 29, 0.9);
            z-index: 10;
            pointer-events: none;
        }

        .selected-square {
            position: relative;
        }

        .selected-square::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(0, 255, 0, 0.8);
            z-index: 10;
            pointer-events: none;
        }

        /* Enhanced piece dragging styles */
        .piece-417db {
            cursor: grab !important;
            transition: transform 0.2s ease;
        }
        .history-container {
            display: flex;
            gap: 20px;
            height: 100%;
            flex-direction: column;
        }

        .games-section, .moves-section {
            flex: 1;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
            z-index: 15;
        }

        .section-header h5 {
            margin: 0;
            color: #aed6ff;
        }

        .scrollable-list {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #f2f2f2;
            border-radius: 4px;
            padding: 10px;
            background: #ffffff;
        }

        .search-container {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .search-input {
            flex: 1;
            padding: 5px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .btn-sm {
            padding: 4px 8px;
            font-size: 12px;
        }

        .loading-placeholder {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
        }

        .game-item, .move-item {
            border-bottom: 1px solid #a19fa7;
            padding: 10px;
            margin-bottom: 10px;
            background: #a19fa7;
            border-radius: 4px;
        }

        .game-item:last-child, .move-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .move-tags {
            font-size: 0.8em;
            color: #060f2e;
            margin-top: 5px;
        }

        .move-notation {
            font-weight: bold;
            color: #3e444d;
        }

        .move-analysis {
            margin: 5px 0;
            font-size: 0.9em;
        }


        .piece-417db:hover {
            transform: scale(1.05);
        }

        .piece-417db.dragging {
            cursor: grabbing !important;
            transform: scale(1.1);
            z-index: 1000 !important;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4) !important;
            transition: none;
        }

        .piece-417db.snapping {
            transition: all 0.3s ease-out !important;
        }

        .engine-info {
            background: #aed6ff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .engine-info h5 {
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
        }

        .engine-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-item {
            background: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            border: 1px solid #dee2e6;
        }

        .stat-label {
            font-size: 0.8em;
            color: #6c757d;
            margin-bottom: 5px;
        }

        .stat-value {
            font-weight: 600;
            color: #2c3e50;
            font-family: monospace;
        }

        .analysis-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .analysis-controls .btn-custom {
            font-size: 0.9em;
            padding: 8px 12px;
        }

        .fen-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 30px;
            border-radius: 10px;
            width: 400px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .modal h3 {
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .modal-buttons {
            margin-top: 25px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            z-index: 10000;
            max-width: 350px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            animation: slideInRight 0.3s ease-out;
        }

        .notification.success { background: #04021c; }
        .notification.error { background: #dc3545; }
        .notification.info { background: #17a2b8; }
        .notification.warning { background: #ffc107; color: #212529; }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .chessboard-container {
            text-align: center;
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        #chessboard {
            margin: 0 auto;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            border-radius: 8px;
            overflow: hidden;
            min-width: 400px;
            min-height: 400px;
        }

        .auto-analyze-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #007bff;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(26px);
        }

        .engine-source {
            background: #ffffff;
            color: #a3d160;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            text-align: center;
            margin-top: 10px;
        }

        .top-moves-container {
            margin-top: 15px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .top-moves-header {
            background: #f8f9fa;
            padding: 8px 12px;
            border-bottom: 1px solid #dee2e6;
            font-weight: 600;
        }
        
        .move-line {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .move-line:hover {
            background-color: #f8f9fa;
        }
        
        .move-line:last-child {
            border-bottom: none;
        }
        
        .move-info {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .move-rank {
            font-weight: 600;
            min-width: 20px;
        }
        
        .move-notation {
            font-family: monospace;
            font-weight: 600;
            min-width: 60px;
        }
        
        .move-eval {
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.85em;
        }
        
        .move-eval.winning { background: #d4edda; color: #c9a2a2; }
        .move-eval.advantage { background: #d1ecf1; color: #ffffff; }
        .move-eval.equal { background: #f8f9fa; color: #6c757d; }
        .move-eval.disadvantage { background: #f8d7da; color: #ffffff; }
        .move-eval.losing { background: #f5c6cb; color: #ffffff; }
        .move-eval.mate { background: #ffffff; color: white; }
        
        .move-pv {
            font-family: monospace;
            font-size: 0.85em;
            color: #6c757d;
            margin-bottom: 2px;
        }
        
        .move-stats {
            font-size: 0.75em;
            color: #868e96;
        }

        @media (max-width: 768px) {
            .content-area {
                flex-direction: column;
            }
            
            .controls-section {
                width: 100%;
                border-left: none;
                border-top: 1px solid #4d5f65;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .main-container {
                margin: 10px;
                border-radius: 10px;
            }
        }
                /* Coach Review Window */
        .coach-review-container {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
            width: 100%;
            max-width: 600px; /* Limit maximum width */
        }

        .coach-review-header {
            background: linear-gradient(45deg, #05040f, #5f0707);
            color: white;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #dee2e6;
        }

        .coach-review-header h5 {
            margin: 0;
            font-size: 1.1em;
            font-weight: 600;
        }

        .coach-review-controls {
            display: flex;
            gap: 8px;
        }

        .btn-mini {
            padding: 4px 8px;
            font-size: 0.8em;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-mini.btn-primary {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .btn-mini.btn-primary:hover {
            background: rgba(255,255,255,0.3);
        }

        .btn-mini.btn-secondary {
            background: rgba(0,0,0,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn-mini.btn-secondary:hover {
            background: rgba(0,0,0,0.2);
        }

        .coach-review-content {
            padding: 20px;
            min-height: 150px;
            max-height: 300px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .coach-placeholder {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            padding: 40px 20px;
        }

        .coach-review-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 4px solid #0d1126;
        }
        /* Add this to your existing CSS */
        .coach-tags-container {
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #17a2b8;
        }

        .coach-tag {
            display: inline-block;
            background: #17a2b8;
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin: 2px 4px 2px 0;
            font-weight: 500;
        }

        .coach-tag:hover {
            background: #138496;
        }

        /* Different colors for different tag types */
        .coach-tag:nth-child(odd) { background: #28a745; }
        .coach-tag:nth-child(3n) { background: #ffc107; color: #212529; }
        .coach-tag:nth-child(4n) { background: #dc3545; }
        .coach-tag:nth-child(5n) { background: #6f42c1; }


        .coach-review-item:last-child {
            margin-bottom: 0;
        }

        .coach-review-type {
            font-weight: 600;
            color: #0d1126;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .coach-review-text {
            color: #495057;
            line-height: 1.4;
            font-size: 0.95em;
        }

        .coach-review-move {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-weight: 600;
            color: #495057;
        }




    </style>
</head>
<body>
    <div class="main-container">
        <!-- Header -->
        <div class="header">
            <h1> Chess Board</h1>
            <p> Python Chess Engine with Deep Analysis</p>
        </div>

        <!-- Main Content Area -->
        <div class="content-area">
            <!-- Chess Board Section -->
            <div class="board-section">
                <!-- Tab Navigation -->
                <div class="tab-navigation">
                    <button class="tab-btn active" onclick="switchTab('play',event)">Play Mode</button>
                    <button class="tab-btn" onclick="switchTab('analyze',event)">Analyze Mode</button>
                     <button class="tab-btn" onclick="switchTab('history',event)">Game History</button>
                    
                </div>

                <!-- Chess Board and Evaluation Container -->
                <div class="board-eval-container">
                <!-- Top section with board and eval bar -->
                    <div class="board-top-section">
                    <!-- Chess Board -->

                    <div class="chessboard-container">
                        <div id="chessboard"></div>
                    </div>
                    
                    <!-- Evaluation Bar (only visible in analyze mode) -->
                    <div class="eval-bar-container" id="evalBarContainer" style="display: none;">
                        
                        <div class="evaluation-bar" id="evalBar">
                            <div class="eval-white" id="evalWhite"></div>
                            <div class="eval-black" id="evalBlack"></div>
                        </div>
                        <div class="eval-value" id="evalValue">0.0</div>
                    </div>
                </div>
                <!-- Coach Review Window (only visible in analyze mode) -->
                <div class="coach-review-container" id="coachReviewContainer" style="display: none;">
                    <div class="coach-review-header">
                        <h5>Coach Review</h5>
                        <div class="coach-review-controls">
                            <button class="btn-mini btn-primary" onclick="generateCoachReview()">Generate Review</button>
                            <button class="btn-mini btn-secondary" onclick="clearCoachReview()">Clear</button>
                        </div>
                    </div>
                    <div class="coach-review-content" id="coachReviewContent">
                        <div class="coach-placeholder">
                            <p> Click "Generate Review" to get AI-powered position analysis and suggestions</p>
                        </div>
                    </div>
                </div>
                </div>


                <!-- Game Controls -->
                <div class="game-controls">
                    <button class="btn-custom btn-primary-custom" onclick="newGame()">New Game</button>
                    <button class="btn-custom btn-secondary-custom" onclick="flipBoard()">Flip Board</button>
                    <button class="btn-custom btn-success-custom" onclick="exportGame()">Export PGN</button>
                    <button class="btn-custom btn-danger-custom" onclick="resignGame()">Resign</button>
                </div>
            </div>
            

            <!-- Controls Section -->
            <div class="controls-section">
                <!-- Play Mode Tab -->
                <div id="playTab" class="tab-content active">
                    <!-- Game Status -->
                    <div class="game-info">
                        <h5>Game Status</h5>
                        <div class="status-item">
                            <span class="status-label">Status:</span>
                            <span class="status-value" id="gameStatus">Active</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Turn:</span>
                            <span class="status-value" id="currentTurn">White</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">FEN:</span>
                            <span class="status-value" id="currentFen">-</span>
                        </div>
                    </div>

                    <!-- Move History -->
                    <div>
                        <h5>Move History</h5>
                        <div class="move-history" id="moveHistory">Game started. Make your first move!</div>
                    </div>
                </div>

                <!-- Analyze Mode Tab -->
                <div id="analyzeTab" class="tab-content">
                    <!-- Auto-Analyze Toggle -->
                    <div class="auto-analyze-toggle">
                        <span>Auto-Analyze:</span>
                        <div class="toggle-switch" id="autoAnalyzeToggle" onclick="toggleAutoAnalyze()">
                            <div class="toggle-slider"></div>
                        </div>
                    </div>

                    <!-- Analysis Controls -->
                    <div class="analysis-controls">
                        <button class="btn-custom btn-primary-custom" id="analyzeBtn">Analyze Position</button>
                        <button class="btn-custom btn-secondary-custom" onclick="resetPosition()">Reset Position</button>
                        <button class="btn-custom btn-success-custom" id="quickAnalysisBtn">Quick Analysis</button>
                        <button class="btn-custom btn-secondary-custom" onclick="flipBoard()">Flip Board</button>
                        <button class="btn-custom btn-success-custom" id="tacticalAnalysisBtn">Tactical Analysis</button>
                        <button class="btn-custom btn-primary-custom" id="deepAnalysisBtn">Deep Analysis</button>
                    </div>

                    <!-- Test Python Engine -->
                    <button class="btn-custom btn-success-custom w-100 mb-3" id="testPythonEngineBtn">Test Python Engine</button>

                    <!-- Engine Analysis Info -->
                    <div class="engine-info">
                        <h5>Engine Analysis</h5>
                        <div class="text-center mb-3">
                            <span id="engineStatus" class="engine-status">Engine Stopped</span>
                        </div>
                        
                        <div class="engine-stats">
                            <div class="stat-item">
                                <div class="stat-label">Best Move</div>
                                <div class="stat-value" id="bestMove">-</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Depth</div>
                                <div class="stat-value" id="engineDepth">-</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Evaluation</div>
                                <div class="stat-value" id="engineEval">0.0</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Nodes</div>
                                <div class="stat-value" id="engineNodes">-</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Time</div>
                                <div class="stat-value" id="engineTime">-</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">NPS</div>
                                <div class="stat-value" id="engineNPS">-</div>
                            </div>
                        </div>

                        <div class="engine-source" id="engineSource">Python Engine</div>
                        
                        <!-- Top moves will be inserted here -->
                        <div id="topMovesContainer"></div>
                    </div>

                    <!-- Position Setup -->
                    <div>
                        <h5 style="z-index: 20; color: white; font-size: 20px; position: relative;">Position Setup</h5>

                        <div class="status-item mb-2">
                            <span class="status-label">Turn:</span>
                            <span class="status-value" id="analyzeTurn">White</span>
                        </div>
                        <div class="status-item mb-3">
                            <span class="status-label"style="z-index:20;">FEN:</span>
                            <span class="status-value" id="analyzeFen">-</span>
                        </div>
                        
                        <input type="text" 
                               class="fen-input" 
                               id="fenInput" 
                               placeholder="Enter FEN string..."
                               value=" ">
                        <button class="btn-custom btn-primary-custom w-100" onclick="loadFenPosition()">▶️ Load Position</button>
                    </div>
                </div>
                                <!-- Game History Tab -->
                <div id="historyTab" class="tab-content">
                    <div class="history-container">
                        <!-- Games section -->
                        <div class="games-section">
                            <div class="section-header">
                                <h5>Saved Games</h5>
                                <button class="btn-custom btn-primary-custom btn-sm" onclick="saveCurrentGame()">Save Current Game</button>
                            </div>
                            <div id="games-list" class="scrollable-list">
                                <div class="loading-placeholder">Loading games...</div>
                            </div>
                        </div>
                        
                        <!-- Moves section -->
                        <div class="moves-section">
                            <div class="section-header">
                                <h5>Bookmarked Moves</h5>
                                <button class="btn-custom btn-success-custom btn-sm" onclick="bookmarkCurrentMove()">Bookmark Current Move</button>
                            </div>
                            <div class="search-container">
                                <input type="text" id="moves-search" placeholder="Search moves by tags..." class="search-input">
                                <button class="btn-custom btn-secondary-custom btn-sm" onclick="searchMoves()">Search</button>
                                <button class="btn-custom btn-secondary-custom btn-sm" onclick="clearSearch()">Clear</button>
                            </div>
                            <div id="moves-list" class="scrollable-list">
                                <div class="loading-placeholder">Loading moves...</div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <h3 id="gameOverTitle">Game Over</h3>
            <p id="gameOverMessage"></p>
            <div class="modal-buttons">
                <button class="btn-custom btn-primary-custom" onclick="closeGameOverModal()">Close</button>
                <button class="btn-custom btn-success-custom" onclick="newGame(); closeGameOverModal();">New Game</button>
            </div>
        </div>
    </div>

    <!-- Load JavaScript files in correct order -->
    <!-- jQuery first -->
    <script src="node_modules/jquery/dist/jquery.min.js"></script>
    <script>var exports = {};</script>
    
    <!-- Chess.js - Use browser compatible version -->
    <script src="node_modules/chess.js/dist/cjs/chess.js"></script>
    
    <!-- Chessboard.js -->
    <script src="js/chessboard-1.0.0.js"></script>
    
    <!-- Your custom JavaScript files -->
    <script src="python-chess-bridge.js"></script>
    <script src="enhanced-chess-analyzer.js"></script>
    <script src="updated-chess-ui-integration.js"></script>
    <script>
        // ✅ Debug class loading
        console.log('🔍 Checking class availability:');
        console.log('PythonChessBridge available:', typeof PythonChessBridge);
        console.log('EnhancedChessAnalyzer available:', typeof EnhancedChessAnalyzer);
        console.log('UpdatedChessUIIntegration available:', typeof UpdatedChessUIIntegration);
        
        // ✅ Test PythonChessBridge constructor
        if (typeof PythonChessBridge !== 'undefined') {
            const testBridge = new PythonChessBridge();
            console.log('🧪 Test bridge serverUrl:', testBridge.serverUrl);
        }
    </script>

    <script>
        // Global variables
        let game = new Chess();
        let analyzeGame = new Chess();
        let board = null;
        let currentTab = 'play';
        let uiIntegration = null;
        
        // Custom drag and drop variables (like your sample code)
        let isDragging = false;
        let draggedPiece = null;
        let draggedFrom = null;
        let startX = 0;
        let startY = 0;
        let originalX = 0;
        let originalY = 0;

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('🚀 Initializing Enhanced Chess Board...');
            
            // Check if Chess.js is loaded properly
            if (typeof Chess === 'undefined') {
                console.error('❌ Chess.js not loaded properly');
                showNotification('Chess.js failed to load. Please check your installation.', 'error');
                return;
            }

            // Check if Chessboard is loaded properly
            if (typeof Chessboard === 'undefined') {
                console.error('❌ Chessboard.js not loaded properly');
                showNotification('Chessboard.js failed to load. Please check your installation.', 'error');
                return;
            }
            if (typeof PythonChessBridge === 'undefined') {
                console.error('❌ PythonChessBridge class not loaded!');
                return;
            }
            
            console.log('✅ Chess.js and Chessboard.js loaded successfully');
            
            // Initialize chess board
            initializeBoard();
            
            // Initialize UI integration with Python engine
            try {
                uiIntegration = new UpdatedChessUIIntegration();
                await uiIntegration.initialize();
                console.log('✅ UI Integration initialized successfully');
                
                // Set up event listeners after UI integration is ready
                setupAnalysisButtons();
                
            } catch (error) {
                console.error('❌ Failed to initialize UI integration:', error);
                showNotification('Failed to initialize Python engine. Using basic features only.', 'warning');
            }
            
            // Update initial board state
            updateGameInfo();
            updateAnalyzeInfo();
            
            console.log('🎉 Chess Board initialization complete!');
        });

        function setupAnalysisButtons() {
            const analyzeBtn = document.getElementById('analyzeBtn');
            const quickBtn = document.getElementById('quickAnalysisBtn');
            const tacticalBtn = document.getElementById('tacticalAnalysisBtn');
            const deepBtn = document.getElementById('deepAnalysisBtn');
            const testBtn = document.getElementById('testPythonEngineBtn');

            if (analyzeBtn && uiIntegration) {
                analyzeBtn.onclick = () => uiIntegration.analyzeCurrentPosition();
            }
            if (quickBtn && uiIntegration) {
                quickBtn.onclick = () => uiIntegration.quickAnalysis();
            }
            if (tacticalBtn && uiIntegration) {
                tacticalBtn.onclick = () => uiIntegration.tacticalAnalysis();
            }
            if (deepBtn && uiIntegration) {
                deepBtn.onclick = () => uiIntegration.deepAnalysis();
            }
            if (testBtn && uiIntegration) {
                testBtn.onclick = () => uiIntegration.testPythonEngine();
            }
        }

        function initializeBoard() {
            const config = {
                draggable: false, // Disable chessboard.js dragging - we'll handle it ourselves
                position: 'start',
                pieceTheme: 'img/chesspieces/wikipedia/{piece}.png'
            };

            board = Chessboard('chessboard', config);
            
            setTimeout(() => {
                addBoardClickHandler();
                setupCustomDragDrop(); // Setup our custom drag and drop like your sample
            }, 100);
            
            // Resize board to fit container
            window.addEventListener('resize', function() {
                board.resize();
            });
        }

        // Custom drag and drop implementation (like your sample code)
        function setupCustomDragDrop() {
            const boardElement = document.getElementById('chessboard');
            
            // Add event listeners to all pieces
            attachPieceEventListeners();
            
            // Global mouse events
            document.addEventListener('mousemove', handleGlobalMouseMove);
            document.addEventListener('mouseup', handleGlobalMouseUp);
            document.addEventListener('mouseleave', handleGlobalMouseLeave);
            
            // ESC key to cancel drag
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && isDragging) {
                    releasePiece('Move cancelled');
                }
            });
        }

        function attachPieceEventListeners() {
            // Wait for pieces to be rendered
            setTimeout(() => {
                const pieces = document.querySelectorAll('.piece-417db');
                pieces.forEach(piece => {
                    piece.addEventListener('mousedown', handlePieceMouseDown);
                    piece.addEventListener('dragstart', e => e.preventDefault()); // Prevent default drag
                });
            }, 200);
        }

        function handlePieceMouseDown(e) {
            e.preventDefault();
            
            const piece = e.currentTarget;
            const square = piece.parentElement.getAttribute('data-square');
            
            if (!square) return;
            
            const currentGame = getCurrentGame();
            
            // Check if game is over
            if (currentGame.isGameOver()) {
                showNotification('Game is over! Start a new game to continue.', 'info');
                return;
            }
            
            // Check if it's the right player's turn
            const pieceColor = piece.getAttribute('data-piece').charAt(0);
            if ((currentGame.turn() === 'w' && pieceColor === 'b') ||
                (currentGame.turn() === 'b' && pieceColor === 'w')) {
                showNotification(`It's ${currentGame.turn() === 'w' ? 'White' : 'Black'}'s turn!`, 'warning');
                return;
            }
            
            startDrag(e, piece, square);
        }

        function startDrag(e, piece, square) {
            isDragging = true;
            draggedPiece = piece;
            draggedFrom = square;
            
            // Add dragging class for visual feedback
            piece.classList.add('dragging');
            piece.classList.remove('snapping');
            
            // Calculate mouse offset
            const rect = piece.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
            
            // Store original position
            originalX = rect.left;
            originalY = rect.top;
            
            // Set piece position to absolute for dragging
            piece.style.position = 'fixed';
            piece.style.left = (e.clientX - startX) + 'px';
            piece.style.top = (e.clientY - startY) + 'px';
            piece.style.zIndex = '1000';
            
            // Highlight possible moves
            highlightPossibleMoves(square);
            
            console.log('Started dragging piece from', square);
        }

        function handleGlobalMouseMove(e) {
            if (!isDragging || !draggedPiece) return;
            
            // Update piece position
            draggedPiece.style.left = (e.clientX - startX) + 'px';
            draggedPiece.style.top = (e.clientY - startY) + 'px';
        }

        function handleGlobalMouseUp(e) {
            if (!isDragging || !draggedPiece) return;
            
            const dropTarget = getDropTarget(e.clientX, e.clientY);
            
            if (dropTarget && dropTarget !== draggedFrom) {
                // Attempt to make the move with try-catch to handle illegal moves
                const currentGame = getCurrentGame();
                
                try {
                    const move = currentGame.move({
                        from: draggedFrom,
                        to: dropTarget,
                        promotion: 'q'
                    });
                    
                    // If we get here, the move was legal
                    if (move) {
                        completeLegalMove();
                    } else {
                        // This shouldn't happen, but just in case
                        releasePiece('Move failed');
                    }
                    
                } catch (error) {
                    // Chess.js threw an error - this means illegal move
                    console.log(`Illegal move attempted: ${draggedFrom} to ${dropTarget}`, error.message);
                    releasePiece('Illegal move! Piece returned to original square.');
                }
            } else {
                // No valid target or same square - release piece
                releasePiece('Piece returned to original square.');
            }
        }

        function handleGlobalMouseLeave(e) {
            if (isDragging && draggedPiece) {
                releasePiece('Piece returned to original square.');
            }
        }

        function getDropTarget(clientX, clientY) {
            const squares = document.querySelectorAll('[data-square]');
            
            for (let square of squares) {
                const rect = square.getBoundingClientRect();
                if (clientX >= rect.left && clientX <= rect.right &&
                    clientY >= rect.top && clientY <= rect.bottom) {
                    return square.getAttribute('data-square');
                }
            }
            
            return null;
        }

        function completeLegalMove() {
            // Reset piece styling
            draggedPiece.classList.remove('dragging');
            draggedPiece.classList.add('snapping');
            draggedPiece.style.position = '';
            draggedPiece.style.left = '';
            draggedPiece.style.top = '';
            draggedPiece.style.zIndex = '';
            
            // Update board position
            const currentGame = getCurrentGame();
            board.position(currentGame.fen());
            
            // Clear indicators
            clearMoveIndicators();
            
            // Update game info
            updateGameInfo();
            updateAnalyzeInfo();
            
            // Trigger auto-analysis if enabled
            if (uiIntegration && currentTab === 'analyze') {
            if (uiIntegration && uiIntegration.autoAnalyze) {
                setTimeout(() => {
                    uiIntegration.analyzeCurrentPosition();
                }, 100);
            }}
            
            // Check for game over
            if (currentGame.isGameOver()) {
                setTimeout(function() {
                    showGameOverModal(currentGame);
                }, 100);
            }
            
            // Reset drag state
            resetDragState();
            
            // Re-attach event listeners to new pieces
            setTimeout(() => {
                attachPieceEventListeners();
            }, 100);
        }

        function releasePiece(message = 'Piece returned to original square.') {
            if (!draggedPiece) return;
            
            // Reset piece styling immediately (same as ESC logic)
            draggedPiece.classList.remove('dragging', 'snapping');
            draggedPiece.style.position = '';
            draggedPiece.style.left = '';
            draggedPiece.style.top = '';
            draggedPiece.style.zIndex = '';
            
            // Clear indicators
            clearMoveIndicators();
            
            // Reset drag state
            resetDragState();
            
            showNotification(message, 'info');
        }

        function snapBack() {
            releasePiece('Piece returned to original square.');
        }

        function cancelDrag() {
            if (isDragging && draggedPiece) {
                releasePiece('Move cancelled');
            }
        }

        function resetDragState() {
            isDragging = false;
            draggedPiece = null;
            draggedFrom = null;
            startX = 0;
            startY = 0;
            originalX = 0;
            originalY = 0;
        }

        function highlightPossibleMoves(square) {
            const currentGame = getCurrentGame();
            const moves = currentGame.moves({
                square: square,
                verbose: true
            });
            
            // Clear any existing indicators
            clearMoveIndicators();
            
            // Add indicator to the selected square
            addSquareIndicator(square, 'selected-square');
            
            // Add indicators to possible move squares
            moves.forEach(move => {
                const targetSquare = move.to;
                const indicatorClass = move.captured ? 'capture-indicator' : 'move-indicator';
                addSquareIndicator(targetSquare, indicatorClass);
            });
            
            console.log(`Added ${moves.length} move indicators for piece on ${square}`);
        }

        function addSquareIndicator(square, cssClass) {
            const squareEl = document.querySelector(`[data-square="${square}"]`);
            if (squareEl) {
                squareEl.classList.add(cssClass);
            }
        }

        function clearMoveIndicators() {
            // Remove all indicator classes
            document.querySelectorAll('.move-indicator, .capture-indicator, .selected-square').forEach(el => {
                el.classList.remove('move-indicator', 'capture-indicator', 'selected-square');
            });
        }

        function addBoardClickHandler() {
            // Add click handler to board to clear indicators when clicking empty squares
            document.getElementById('chessboard').addEventListener('click', function(e) {
                // If clicking on an empty square, clear indicators
                if (e.target.classList.contains('square-55d63')) {
                    clearMoveIndicators();
                }
            });
        }

        function getCurrentGame() {
            return currentTab === 'analyze' ? analyzeGame : game;
        }

        function makeMove(moveStr) {
            const currentGame = getCurrentGame();
            const move = currentGame.move(moveStr);
            
            if (move) {
                board.position(currentGame.fen());
                updateGameInfo();
                updateAnalyzeInfo();
                
                // Re-attach event listeners after board update
                setTimeout(() => {
                    attachPieceEventListeners();
                }, 100);
                
                return true;
            }
            return false;
        }

        function updateGameInfo() {
            const currentGame = getCurrentGame();
            
            // Update status
            let status = 'Active';
            if (currentGame.isCheckmate()) {
                status = 'Checkmate';
            } else if (currentGame.isDraw()) {
                status = 'Draw';
            } else if (currentGame.inCheck()) {
                status = 'Check';
            }
            
            document.getElementById('gameStatus').textContent = status;
            document.getElementById('currentTurn').textContent = currentGame.turn() === 'w' ? 'White' : 'Black';
            document.getElementById('currentFen').textContent = currentGame.fen();
            
            // Update move history
            const history = currentGame.history({ verbose: true });
            let historyHtml = '';
            
            for (let i = 0; i < history.length; i += 2) {
                const moveNumber = Math.floor(i / 2) + 1;
                const whiteMove = history[i] ? history[i].san : '';
                const blackMove = history[i + 1] ? history[i + 1].san : '';
                historyHtml += `<div>${moveNumber}. ${whiteMove} ${blackMove}</div>`;
            }
            
            if (historyHtml === '') {
                historyHtml = 'Game started. Make your first move!';
            }
            
            document.getElementById('moveHistory').innerHTML = historyHtml;
        }

        function updateAnalyzeInfo() {
            const currentGame = getCurrentGame();
            document.getElementById('analyzeTurn').textContent = currentGame.turn() === 'w' ? 'White' : 'Black';
            document.getElementById('analyzeFen').textContent = currentGame.fen();
        }
        function switchTab(tabName,event=null) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));

            // Handle event target safely
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // When called programmatically, find the right button
                const targetButton = Array.from(document.querySelectorAll('.tab-btn')).find(
                    btn => btn.onclick && btn.onclick.toString().includes(`switchTab('${tabName}')`)
                );
                if (targetButton) {
                    targetButton.classList.add('active');
                }
            }

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Show/hide evaluation bar based on tab
            const evalBarContainer = document.getElementById('evalBarContainer');
            if (evalBarContainer) {
                evalBarContainer.style.display = tabName === 'analyze' ? 'flex' : 'none';
            }
            
            // Show/hide coach review based on tab
            const coachReviewContainer = document.getElementById('coachReviewContainer');
            if (coachReviewContainer) {
                coachReviewContainer.style.display = tabName === 'analyze' ? 'block' : 'none';
            }
            
            // Update current tab
            currentTab = tabName;
            
            // Handle tab-specific logic
            if (tabName === 'history') {
                // Load history data when history tab is opened
                loadGames();
                loadMoves();
            } else {
                // Update board position for play/analyze tabs
                const currentGame = getCurrentGame();
                board.position(currentGame.fen());
                
                // Re-attach event listeners after board update
                setTimeout(() => {
                    attachPieceEventListeners();
                }, 100);
                
                // Update info displays
                updateGameInfo();
                updateAnalyzeInfo();
            }
        }


        function newGame() {
            game.reset();
            analyzeGame.reset();
            board.start();
            updateGameInfo();
            updateAnalyzeInfo();
            clearMoveIndicators();
            resetDragState();
            
            // Reset evaluation bar
            updateEvalBar(0);
            
            // Re-attach event listeners after board reset
            setTimeout(() => {
                attachPieceEventListeners();
            }, 100);
            
            // Clear analysis if UI integration is available
            if (uiIntegration && uiIntegration.clearAnalysisDisplay) {
                uiIntegration.clearAnalysisDisplay();
            }
            
            showNotification('New game started!', 'success');
        }

        function flipBoard() {
            board.flip();
            
            // Re-attach event listeners after flip
            setTimeout(() => {
                attachPieceEventListeners();
            }, 100);
            
            showNotification('Board flipped!', 'info');
        }

        function resetPosition() {
            const currentGame = getCurrentGame();
            currentGame.reset();
            board.start();
            updateGameInfo();
            updateAnalyzeInfo();
            clearMoveIndicators();
            resetDragState();
            
            // Reset evaluation bar
            updateEvalBar(0);
            
            // Re-attach event listeners after reset
            setTimeout(() => {
                attachPieceEventListeners();
            }, 100);
            
            if (uiIntegration && uiIntegration.clearAnalysisDisplay) {
                uiIntegration.clearAnalysisDisplay();
            }
            
            showNotification('Position reset to starting position!', 'info');
        }

        function loadFenPosition() {
            const fenInput = document.getElementById('fenInput');
            const fen = fenInput.value.trim();
            
            if (!fen) {
                showNotification('Please enter a FEN string!', 'error');
                return;
            }
            
            try {
                const currentGame = getCurrentGame();
                currentGame.load(fen);
                board.position(fen);
                updateGameInfo();
                updateAnalyzeInfo();
                clearMoveIndicators();
                resetDragState();
                
                // Reset evaluation bar
                updateEvalBar(0);
                
                // Re-attach event listeners after position load
                setTimeout(() => {
                    attachPieceEventListeners();
                }, 100);
                
                showNotification('Position loaded successfully!', 'success');
            } catch (error) {
                showNotification('Invalid FEN string!', 'error');
                console.error('FEN load error:', error);
            }
        }

        function exportGame() {
            const currentGame = getCurrentGame();
            const pgn = currentGame.pgn();
            
            if (!pgn) {
                showNotification('No moves to export!', 'warning');
                return;
            }
            
            // Create download
            const blob = new Blob([pgn], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chess_game_${Date.now()}.pgn`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('Game exported as PGN!', 'success');
        }

        function resignGame() {
            const currentGame = getCurrentGame();
            if (currentGame.isGameOver()) {
                showNotification('Game is already over!', 'info');
                return;
            }
            
            const winner = currentGame.turn() === 'w' ? 'Black' : 'White';
            showGameOverModal(currentGame, `${winner} wins by resignation!`);
        }

        function showGameOverModal(gameObj, customMessage = null) {
            let message = customMessage;
            
            if (!message) {
                if (gameObj.isCheckmate()) {
                    const winner = gameObj.turn() === 'w' ? 'Black' : 'White';
                    message = `Checkmate! ${winner} wins!`;
                } else if (gameObj.isDraw()) {
                    if (gameObj.isStalemate()) {
                        message = 'Game ends in stalemate!';
                    } else if (gameObj.isInsufficientMaterial()) {
                        message = 'Draw due to insufficient material!';
                    } else if (gameObj.isThreefoldRepetition()) {
                        message = 'Draw due to threefold repetition!';
                    } else {
                        message = 'Game ends in a draw!';
                    }
                }
            }
            
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOverModal').style.display = 'block';
        }

        function closeGameOverModal() {
            document.getElementById('gameOverModal').style.display = 'none';
        }

        function toggleAutoAnalyze() {
            const toggle = document.getElementById('autoAnalyzeToggle');
            toggle.classList.toggle('active');
            
            if (uiIntegration && uiIntegration.toggleAutoAnalyze) {
                uiIntegration.toggleAutoAnalyze();
            }
        }
        async function generateCoachReview() {
    const content = document.getElementById('coachReviewContent');
    const currentGame = getCurrentGame();
    
    if (!currentGame) {
        showNotification('No game available for analysis', 'error');
        return;
    }
    
    // Show loading state
    content.innerHTML = '<div class="coach-placeholder"><p>Analyzing position and getting best moves...</p></div>';
    showNotification('Getting chess engine analysis...', 'info');
    
    try {
        // Get current position data
        const fen = currentGame.fen();
        const turn = currentGame.turn() === 'w' ? 'White' : 'Black';
        
        // First, get best moves from chess engine using the correct method from your UI integration
        let bestMoves = [];
        if (uiIntegration && uiIntegration.analyzer) {
            try {
                showNotification('Getting best moves from engine...', 'info');
                
                // Use the correct method from your updated-chess-ui-integration.js
                const analysis = await uiIntegration.analyzer.getTopMoves(fen, { 
                    depth: 7, 
                    useCache: true, 
                    timeout: 40000 
                });
                
                if (analysis && analysis.success && analysis.bestMoves && analysis.bestMoves.length > 0) {
                    // Extract top 3 moves with their evaluations - matching your code structure
                    bestMoves = analysis.bestMoves.slice(0, 3).map(move => ({
                        move: move.san || move.move,
                        uci: move.move,
                        evaluation: move.evaluation || move.eval_score || move.evaluationRaw,
                        pv: move.principalVariation || move.pv || [],
                        depth: move.depth,
                        nodes: move.nodes
                    }));
                    console.log('✅ Got best moves from engine:', bestMoves);
                } else {
                    console.warn('⚠️ No best moves from engine analysis');
                    // Try alternative method if getTopMoves doesn't work
                    try {
                        const quickAnalysis = await uiIntegration.analyzer.quickEvaluation(fen);
                        if (quickAnalysis && quickAnalysis.bestMoves) {
                            bestMoves = quickAnalysis.bestMoves.slice(0, 3).map(move => ({
                                move: move.san || move.move,
                                uci: move.move,
                                evaluation: move.evaluation || move.eval_score,
                                pv: move.principalVariation || move.pv || []
                            }));
                        }
                    } catch (fallbackError) {
                        console.warn('Fallback analysis also failed:', fallbackError);
                    }
                }
            } catch (engineError) {
                console.error('Engine analysis failed:', engineError);
                showNotification('Engine analysis failed, using AI-only review...', 'warning');
            }
        } else {
            console.warn('UI Integration or analyzer not available');
            showNotification('Engine not available, using AI-only review...', 'warning');
        }
        
        // Update loading message
        content.innerHTML = '<div class="coach-placeholder"><p>🤖 Generating AI coach review with best moves...</p></div>';
        showNotification('Generating AI coach review...', 'info');
        
        // Make API call to backend with best moves
        const response = await fetch('http://192.168.29.161:8000/coach-review', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                fen: fen,
                turn: turn,
                bestMoves: bestMoves // Include best moves from engine
            }),
            signal: AbortSignal.timeout(45000) // 45 second timeout
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.status === 'success') {
            displayEnhancedCoachReview(data.review, bestMoves);
            showNotification('AI coach review generated!', 'success');
        } else {
            throw new Error(data.error || 'Unknown error');
        }
        
    } catch (error) {
        console.error('Coach review error:', error);
        showNotification('Failed to generate coach review: ' + error.message, 'error');
        
        // Show fallback content
        content.innerHTML = `
            <div class="coach-placeholder">
                <p>❌ Unable to generate AI review</p>
                <p>Error: ${error.message}</p>
                <button class="btn-mini btn-primary" onclick="generateCoachReview()">Try Again</button>
            </div>
        `;
    }
}
function displayEnhancedCoachReview(review, engineMoves = []) {
    const content = document.getElementById('coachReviewContent');
    
    // Create tags display
    const tagsHtml = review.tags ? review.tags.map(tag => 
        `<span class="coach-tag">${tag}</span>`
    ).join('') : '';
    
    let html = '';
    
    // Add tags if available
    if (tagsHtml) {
        html += `<div class="coach-tags-container">${tagsHtml}</div>`;
    }
    
    // Add position assessment
    if (review.position_assessment) {
        html += `
            <div class="coach-review-item">
                <div class="coach-review-type">📊 Position Assessment</div>
                <div class="coach-review-text">${review.position_assessment}</div>
            </div>
        `;
    }
    
    // Add best moves with AI explanations
    if (review.best_move_1 || review.best_move_2 || review.best_move_3) {
        html += `
            <div class="coach-review-item">
                <div class="coach-review-type">🎯 Best Moves Analysis</div>
                <div class="coach-review-text">
                    <div class="best-move-item">${review.best_move_1 || 'Move 1: Analysis needed'}</div>
                    <div class="best-move-item">${review.best_move_2 || 'Move 2: Analysis needed'}</div>
                    <div class="best-move-item">${review.best_move_3 || 'Move 3: Analysis needed'}</div>
                </div>
            </div>
        `;
    }
    
    // Add tactical opportunities
    if (review.tactical_opportunities) {
        html += `
            <div class="coach-review-item">
                <div class="coach-review-type">⚔️ Tactical Opportunities</div>
                <div class="coach-review-text">${review.tactical_opportunities}</div>
            </div>
        `;
    }
    
    // Add strategic advice
    if (review.strategic_advice) {
        html += `
            <div class="coach-review-item">
                <div class="coach-review-type">🧠 Strategic Advice</div>
                <div class="coach-review-text">${review.strategic_advice}</div>
            </div>
        `;
    }
    
    // Add engine moves info if available
    if (engineMoves && engineMoves.length > 0) {
        const engineMovesHtml = engineMoves.map((move, index) => 
            `<span class="engine-move" onclick="makeMove('${move.uci || move.move}')">${index + 1}. ${move.move} (${move.evaluation})</span>`
        ).join(' ');
        
        html += `
            <div class="coach-review-item engine-moves-section">
                <div class="coach-review-type">🔧 Engine Moves</div>
                <div class="coach-review-text">Click to play: ${engineMovesHtml}</div>
            </div>
        `;
    }
    
    content.innerHTML = html;
}



function displayCoachReview(review) {
    const content = document.getElementById('coachReviewContent');
    
    // Create tags display
    const tagsHtml = review.tags ? review.tags.map(tag => 
        `<span class="coach-tag">${tag}</span>`
    ).join('') : '';
    
    // Create review sections
    const sections = [
        { type: "Position Assessment", text: review.position_assessment },
        { type: "Tactical Opportunities", text: review.tactical_opportunities },
        { type: "Strategic Advice", text: review.strategic_advice },
        { type: "Next Move Suggestions", text: review.next_move_suggestions }
    ];
    
    let html = '';
    
    // Add tags if available
    if (tagsHtml) {
        html += `<div class="coach-tags-container">${tagsHtml}</div>`;
    }
    
    // Add review sections
    sections.forEach(section => {
        if (section.text) {
            html += `
                <div class="coach-review-item">
                    <div class="coach-review-type">${section.type}</div>
                    <div class="coach-review-text">${section.text}</div>
                </div>
            `;
        }
    });
    
    content.innerHTML = html;
}


        function clearCoachReview() {
            const content = document.getElementById('coachReviewContent');
            content.innerHTML = '<div class="coach-placeholder"><p>🤖 Click "Generate Review" to get AI-powered position analysis and suggestions</p></div>';
            showNotification('Coach review cleared', 'info');
        }
        // Global variables for pagination
        //code for the Datatable
        let gamesOffset = 0;
        let movesOffset = 0;
        const ITEMS_PER_PAGE = 20;
        let isLoadingGames = false;
        let isLoadingMoves = false;

        // Save current game to database
        async function saveCurrentGame() {
            try {
                const currentGame = getCurrentGame();
                if (!currentGame) {
                    showNotification('No game available to save', 'error');
                    return;
                }
                
                // Get PGN from existing export functionality - consistent with exportGame()
                const pgn = currentGame.pgn();
                const finalFen = currentGame.fen();
                
                // Consistent validation with exportGame function
                if (!pgn || pgn.trim() === '') {
                    showNotification('No moves to save! Start playing first.', 'warning');
                    return;
                }
                
                // Check if game has actual moves (not just starting position)
                const history = currentGame.history();
                if (history.length === 0) {
                    showNotification('Cannot save game with no moves', 'warning');
                    return;
                }
                
                // Prompt for game name
                const gameName = prompt("Enter a name for this game (optional):");
                
                // Handle user cancellation
                if (gameName === null) {
                    return;
                }
                
                showNotification('Saving game...', 'info');
                
                // Send to backend
                const response = await fetch('http://192.168.29.161:8000/api/save-game', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        pgn: pgn,
                        final_fen: finalFen,
                        game_name: gameName || null
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    showNotification('Game saved successfully!', 'success');
                    // Refresh games list if history tab is active
                    if (currentTab === 'history') {
                        gamesOffset = 0; // Reset pagination
                        document.getElementById('games-list').innerHTML = '<div class="loading-placeholder">Loading games...</div>';
                        loadGames();
                    }
                } else {
                    throw new Error(data.error || 'Failed to save game');
                }
                
            } catch (error) {
                console.error('Save game error:', error);
                showNotification('Failed to save game: ' + error.message, 'error');
            }
        }

    // Bookmark current move with analysis
    async function bookmarkCurrentMove() {
        try {
            const currentGame = getCurrentGame();
            if (!currentGame) {
                showNotification('No game available for bookmarking', 'error');
                return;
            }
            
            const currentFen = currentGame.fen();
            const history = currentGame.history({verbose: true});
            const lastMove = history.length > 0 ? history[history.length - 1] : null;
            const moveNotation = lastMove ? lastMove.san : 'Starting position';
            
            showNotification('Generating analysis for bookmark...', 'info');
            
            // Generate coach review to get analysis data with tags
            const analysisData = await generateAnalysisForBookmark(currentFen, currentGame.turn());
            
            if (!analysisData) {
                showNotification('Failed to generate analysis for bookmark', 'error');
                return;
            }
            
            showNotification('Saving bookmarked move...', 'info');
            
            // Send to backend
            const response = await fetch('http://192.168.29.161:8000/api/save-move', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    fen: currentFen,
                    move_notation: moveNotation,
                    analysis_data: analysisData
                })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.success) {
                showNotification('Move bookmarked successfully!', 'success');
                // Refresh moves list if history tab is active
                if (currentTab === 'history') {
                    movesOffset = 0; // Reset pagination
                    document.getElementById('moves-list').innerHTML = '<div class="loading-placeholder">Loading moves...</div>';
                    loadMoves();
                }
            } else {
                throw new Error(data.error || 'Failed to bookmark move');
            }
            
        } catch (error) {
            console.error('Bookmark move error:', error);
            showNotification('Failed to bookmark move: ' + error.message, 'error');
        }
    }

    // Generate analysis data for bookmarking (reuses existing coach review logic)
    async function generateAnalysisForBookmark(fen, turn) {
        try {
            const turnText = turn === 'w' ? 'White' : 'Black';
            
            // Get best moves from chess engine (reusing existing logic)
            let bestMoves = [];
            if (uiIntegration && uiIntegration.analyzer) {
                try {
                    const analysis = await uiIntegration.analyzer.getTopMoves(fen, { 
                        depth: 7, 
                        useCache: true, 
                        timeout: 40000 
                    });
                    
                    if (analysis && analysis.success && analysis.bestMoves && analysis.bestMoves.length > 0) {
                        bestMoves = analysis.bestMoves.slice(0, 3).map(move => ({
                            move: move.san || move.move,
                            uci: move.move,
                            evaluation: move.evaluation || move.eval_score || move.evaluationRaw,
                            pv: move.principalVariation || move.pv || [],
                            depth: move.depth,
                            nodes: move.nodes
                        }));
                    }
                } catch (engineError) {
                    console.warn('Engine analysis failed for bookmark:', engineError);
                }
            }
            
            // Make API call to get coach review
            const response = await fetch('http://192.168.29.161:8000/coach-review', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    fen: fen,
                    turn: turnText,
                    bestMoves: bestMoves
                }),
                signal: AbortSignal.timeout(45000)
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.status === 'success') {
                return data.review; // This contains all the analysis data including tags
            } else {
                throw new Error(data.error || 'Failed to get analysis');
            }
            
        } catch (error) {
            console.error('Analysis generation error:', error);
            // Return fallback analysis data
            return {
                position_assessment: "Position analysis unavailable",
                best_move_1: "Analysis needed",
                best_move_2: "Analysis needed", 
                best_move_3: "Analysis needed",
                tactical_opportunities: "Review position manually",
                strategic_advice: "Apply chess principles",
                tags: ["bookmark", "analysis", "position"],
                timestamp: Date.now(),
                source: "fallback_bookmark"
            };
        }
    }

    // Load games with pagination - Fixed infinite scroll bug
    async function loadGames() {
        if (isLoadingGames) return; // Prevent multiple simultaneous requests
        
        try {
            isLoadingGames = true;
            
            const response = await fetch(`http://192.168.29.161:8000/api/games?limit=${ITEMS_PER_PAGE}&offset=${gamesOffset}`);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const games = await response.json();
            const gamesList = document.getElementById('games-list');
            
            // Clear loading placeholder on first load
            if (gamesOffset === 0) {
                gamesList.innerHTML = '';
            }
            
            if (games.length === 0 && gamesOffset === 0) {
                gamesList.innerHTML = '<div class="loading-placeholder">No saved games yet</div>';
                return;
            }
            
            // Add games to list
            games.forEach(game => {
                const gameElement = document.createElement('div');
                gameElement.className = 'game-item';
                gameElement.innerHTML = `
                    <div class="game-header">
                        <h6>${escapeHtml(game.game_name || 'Untitled Game')}</h6>
                        <small>Saved: ${new Date(game.created_at).toLocaleDateString()}</small>
                    </div>
                    <div class="game-fen">FEN: ${escapeHtml(game.final_fen.substring(0, 50))}...</div>
                    <div class="game-actions">
                        <button class="btn-custom btn-primary-custom btn-sm" onclick="loadGameFromHistory(${game.id})">Load Game</button>
                        <button class="btn-custom btn-danger-custom btn-sm" onclick="deleteGame(${game.id})">Delete</button>
                    </div>
                `;
                gamesList.appendChild(gameElement);
            });
            
            gamesOffset += games.length;
            
        } catch (error) {
            console.error('Load games error:', error);
            document.getElementById('games-list').innerHTML = 
                '<div class="loading-placeholder">Error loading games</div>';
        } finally {
            isLoadingGames = false;
        }
    }

    // Load moves with pagination - Fixed infinite scroll bug
    async function loadMoves() {
        if (isLoadingMoves) return; // Prevent multiple simultaneous requests
        
        try {
            isLoadingMoves = true;
            
            const response = await fetch(`http://192.168.29.161:8000/api/moves?limit=${ITEMS_PER_PAGE}&offset=${movesOffset}`);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const moves = await response.json();
            const movesList = document.getElementById('moves-list');
            
            // Clear loading placeholder on first load
            if (movesOffset === 0) {
                movesList.innerHTML = '';
            }
            
            if (moves.length === 0 && movesOffset === 0) {
                movesList.innerHTML = '<div class="loading-placeholder">No bookmarked moves yet</div>';
                return;
            }
            
            
          // In your loadMoves() function, replace the move HTML generation:
moves.forEach(move => {
    const moveElement = document.createElement('div');
    moveElement.className = 'move-item';
    moveElement.innerHTML = `
        <div class="move-header">
            <div class="move-notation">${escapeHtml(move.move_notation)}</div>
            <small>${new Date(move.created_at).toLocaleDateString()}</small>
        </div>
        <div class="move-analysis">${escapeHtml(move.position_assessment || 'No analysis available')}</div>
        <div class="move-tags">${move.tags ? move.tags.map(tag => escapeHtml(tag)).join(', ') : 'No tags'}</div>
        <div class="move-actions">
            <button class="btn-custom btn-primary-custom btn-sm" 
                    onclick="loadPositionFromData(this)" 
                    data-fen="${escapeHtml(move.fen)}"
                    data-best-move-1="${escapeHtml(move.best_move_1 || '')}"
                    data-best-move-2="${escapeHtml(move.best_move_2 || '')}"
                    data-best-move-3="${escapeHtml(move.best_move_3 || '')}"
                    data-tactical-opportunities="${escapeHtml(move.tactical_opportunities || '')}"
                    data-strategic-advice="${escapeHtml(move.strategic_advice || '')}">
                Load Position
            </button>
            <button class="btn-custom btn-danger-custom btn-sm" onclick="deleteMove(${move.id})">Delete</button>
        </div>
    `;
    movesList.appendChild(moveElement);
});


            
            movesOffset += moves.length;
            
        } catch (error) {
            console.error('Load moves error:', error);
            document.getElementById('moves-list').innerHTML = 
                '<div class="loading-placeholder">Error loading moves</div>';
        } finally {
            isLoadingMoves = false;
        }
    }
    function loadPositionFromData(button) {
    const fen = button.getAttribute('data-fen');
    
    // Get all stored analysis data from data attributes
    const moveItem = button.closest('.move-item');
    const moveNotation = moveItem.querySelector('.move-notation')?.textContent || '';
    const positionAssessment = moveItem.querySelector('.move-analysis')?.textContent || '';
    const moveTagsText = moveItem.querySelector('.move-tags')?.textContent || '';
    const tags = moveTagsText === 'No tags' ? [] : moveTagsText.split(', ');
    
    // Get detailed analysis from data attributes
    const storedAnalysis = {
        notation: moveNotation,
        position_assessment: positionAssessment,
        best_move_1: button.getAttribute('data-best-move-1') || '',
        best_move_2: button.getAttribute('data-best-move-2') || '',
        best_move_3: button.getAttribute('data-best-move-3') || '',
        tactical_opportunities: button.getAttribute('data-tactical-opportunities') || '',
        strategic_advice: button.getAttribute('data-strategic-advice') || '',
        tags: tags
    };
    
    console.log('🔍 DEBUG: Loading stored analysis:', storedAnalysis);
    
    // Store globally for display
    window.storedAnalysis = storedAnalysis;
    
    loadPositionFromHistory(fen);
}


    // Search moves by tags
    async function searchMoves() {
        const searchQuery = document.getElementById('moves-search').value.trim();
        
        if (!searchQuery) {
            showNotification('Please enter a search term', 'warning');
            return;
        }
        
        try {
            const response = await fetch(`http://192.168.29.161:8000/api/search-moves?query=${encodeURIComponent(searchQuery)}`);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const moves = await response.json();
            const movesList = document.getElementById('moves-list');
            
            movesList.innerHTML = ''; // Clear existing moves
            
            if (moves.length === 0) {
                movesList.innerHTML = '<div class="loading-placeholder">No moves found for this search</div>';
                return;
            }
            
            moves.forEach(move => {
                const moveElement = document.createElement('div');
                moveElement.className = 'move-item';
                moveElement.innerHTML = `
                    <div class="move-header">
                        <div class="move-notation">${escapeHtml(move.move_notation)}</div>
                        <small>${new Date(move.created_at).toLocaleDateString()}</small>
                    </div>
                    <div class="move-analysis">${escapeHtml(move.position_assessment || 'No analysis available')}</div>
                    <div class="move-tags">${move.tags ? move.tags.map(tag => escapeHtml(tag)).join(', ') : 'No tags'}</div>
                    <div class="move-actions">
                        <button class="btn-custom btn-primary-custom btn-sm" onclick="loadPositionFromHistory('${escapeHtml(move.fen)}')">Load Position</button>
                        <button class="btn-custom btn-danger-custom btn-sm" onclick="deleteMove(${move.id})">Delete</button>
                    </div>
                `;
                movesList.appendChild(moveElement);
            });
            
            showNotification(`Found ${moves.length} moves`, 'success');
            
        } catch (error) {
            console.error('Search moves error:', error);
            showNotification('Search failed: ' + error.message, 'error');
        }
    }

    // Clear search and reload all moves
    function clearSearch() {
        document.getElementById('moves-search').value = '';
        movesOffset = 0; // Reset pagination
        document.getElementById('moves-list').innerHTML = '<div class="loading-placeholder">Loading moves...</div>';
        loadMoves();
    }

   async function loadGameFromHistory(gameId) {
    try {
        console.log('🔍 DEBUG: Starting loadGameFromHistory with gameId:', gameId);
        
        const response = await fetch(`http://192.168.29.161:8000/api/game/${gameId}`);
        console.log('🔍 DEBUG: API response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const gameData = await response.json();
        console.log('🔍 DEBUG: Received gameData:', gameData);
        console.log('🔍 DEBUG: PGN content:', gameData.pgn);
        
        // Check if analyzeGame exists
        console.log('🔍 DEBUG: analyzeGame exists:', typeof analyzeGame);
        console.log('🔍 DEBUG: analyzeGame current FEN before load:', analyzeGame.fen());
        
        // Load PGN - don't check return value, just rely on exception handling
        console.log('🔍 DEBUG: Attempting to load PGN...');
        
        // ✅ FIX: Just call loadPgn and let it throw an error if invalid
        analyzeGame.loadPgn(gameData.pgn);
        console.log('✅ DEBUG: PGN loaded successfully (no exception thrown)');
        
        // Check game state after loading
        console.log('🔍 DEBUG: Game state after loading:');
        console.log('🔍 DEBUG: - FEN:', analyzeGame.fen());
        console.log('🔍 DEBUG: - Move history length:', analyzeGame.history().length);
        console.log('🔍 DEBUG: - Turn:', analyzeGame.turn());
        
        // Switch to analyze mode AFTER loading data
        console.log('🔍 DEBUG: Switching to analyze tab...');
        switchTab('analyze');
        
        // Update board position
        console.log('🔍 DEBUG: Updating board position...');
        const fenToSet = analyzeGame.fen();
        console.log('🔍 DEBUG: Setting board to FEN:', fenToSet);
        board.position(fenToSet);
        
        // Update displays
        console.log('🔍 DEBUG: Updating displays...');
        updateGameInfo();
        updateAnalyzeInfo();
        
        showNotification('Game loaded successfully!', 'success');
        console.log('✅ DEBUG: loadGameFromHistory completed successfully');
        
    } catch (error) {
        console.error('❌ DEBUG: Error in loadGameFromHistory:', error);
        console.error('❌ DEBUG: Error details:', error.message);
        showNotification('Failed to load game: ' + error.message, 'error');
    }
}
function displayStoredAnalysis() {
    if (!window.storedAnalysis) {
        console.log('No stored analysis to display');
        return;
    }
    
    const analysis = window.storedAnalysis;
    const content = document.getElementById('coachReviewContent');
    
    if (!content) {
        console.log('Coach review content element not found');
        return;
    }
    
    // Build the analysis HTML using the stored data
    const analysisHtml = `
        <div class="stored-analysis">
            <div class="analysis-header">
                <h6>📚 Stored Analysis for: ${analysis.notation}</h6>
                <div class="analysis-tags">
                    ${analysis.tags.length > 0 ? analysis.tags.map(tag => `<span class="tag-badge">${tag}</span>`).join('') : 'No tags'}
                </div>
            </div>
            
            <div class="analysis-content">
                <div class="analysis-section">
                    <h6> Position Assessment</h6>
                    <p>${analysis.position_assessment}</p>
                </div>
                
                ${analysis.best_move_1 ? `
                <div class="analysis-section">
                    <h6> Best Moves</h6>
                    <div class="best-moves">
                        ${analysis.best_move_1 ? `<div class="best-move"><strong>1.</strong> ${analysis.best_move_1}</div>` : ''}
                        ${analysis.best_move_2 ? `<div class="best-move"><strong>2.</strong> ${analysis.best_move_2}</div>` : ''}
                        ${analysis.best_move_3 ? `<div class="best-move"><strong>3.</strong> ${analysis.best_move_3}</div>` : ''}
                    </div>
                </div>
                ` : ''}
                
                ${analysis.tactical_opportunities ? `
                <div class="analysis-section">
                    <h6> Tactical Opportunities</h6>
                    <p>${analysis.tactical_opportunities}</p>
                </div>
                ` : ''}
                
                ${analysis.strategic_advice ? `
                <div class="analysis-section">
                    <h6> Strategic Advice</h6>
                    <p>${analysis.strategic_advice}</p>
                </div>
                ` : ''}
            </div>
        </div>
    `;
    
    content.innerHTML = analysisHtml;
    console.log('✅ Stored analysis displayed successfully');
    
    // Clear the stored analysis
    window.storedAnalysis = null;
}

function loadPositionFromHistory(fen) {
    try {
        console.log('🔍 DEBUG: Starting loadPositionFromHistory with FEN:', fen);
        
        // Clean and load FEN
        const cleanFen = fen.trim();
        analyzeGame.load(cleanFen);
        console.log('✅ DEBUG: FEN loaded successfully');
        
        // Switch to analyze mode
        switchTab('analyze');
        
        // Update board position
        board.position(cleanFen);
        
        // Update displays
        updateGameInfo();
        updateAnalyzeInfo();
        
        // ✅ Display stored analysis instead of generating new one
        setTimeout(() => {
            displayStoredAnalysis();
        }, 300);
        
        showNotification('Position and stored analysis loaded!', 'success');
        console.log('✅ DEBUG: loadPositionFromHistory completed successfully');
        
    } catch (error) {
        console.error('❌ DEBUG: Load position error:', error);
        showNotification('Failed to load position: ' + error.message, 'error');
    }
}


    // Delete game
    async function deleteGame(gameId) {
        if (!confirm('Are you sure you want to delete this game?')) {
            return;
        }
        
        try {
            const response = await fetch(`http://192.168.29.161:8000/api/game/${gameId}`, {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            showNotification('Game deleted successfully!', 'success');
            
            // Refresh games list
            gamesOffset = 0;
            document.getElementById('games-list').innerHTML = '<div class="loading-placeholder">Loading games...</div>';
            loadGames();
            
        } catch (error) {
            console.error('Delete game error:', error);
            showNotification('Failed to delete game: ' + error.message, 'error');
        }
    }

    // Delete move
    async function deleteMove(moveId) {
        if (!confirm('Are you sure you want to delete this bookmarked move?')) {
            return;
        }
        
        try {
            const response = await fetch(`http://192.168.29.161:8000/api/move/${moveId}`, {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            showNotification('Move deleted successfully!', 'success');
            
            // Refresh moves list
            movesOffset = 0;
            document.getElementById('moves-list').innerHTML = '<div class="loading-placeholder">Loading moves...</div>';
            loadMoves();
            
        } catch (error) {
            console.error('Delete move error:', error);
            showNotification('Failed to delete move: ' + error.message, 'error');
        }
    }

    // Utility function to escape HTML
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Fixed infinite scroll implementation
    document.addEventListener('DOMContentLoaded', function() {
        const gamesList = document.getElementById('games-list');
        const movesList = document.getElementById('moves-list');
        
        if (gamesList) {
            gamesList.addEventListener('scroll', function() {
                if (this.scrollTop + this.clientHeight >= this.scrollHeight - 10 && !isLoadingGames) {
                    loadGames();
                }
            });
        }
        
        if (movesList) {
            movesList.addEventListener('scroll', function() {
                if (this.scrollTop + this.clientHeight >= this.scrollHeight - 10 && !isLoadingMoves) {
                    loadMoves();
                }
            });
        }
    });



        function showNotification(message, type = 'info') {
            // Remove existing notifications
            document.querySelectorAll('.notification').forEach(n => n.remove());
            
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideOutRight 0.3s ease-in';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }
            }, 5000);
        }

        // Global functions for external access
        window.makeMove = makeMove;
        window.updateBoard = function() {
            const currentGame = getCurrentGame();
            board.position(currentGame.fen());
            updateGameInfo();
            updateAnalyzeInfo();
            
            // Re-attach event listeners after board update
            setTimeout(() => {
                attachPieceEventListeners();
            }, 100);
        };
        window.flipBoard = flipBoard;
        window.showNotification = showNotification;
        
        // Updated evaluation bar function for chess.com style
               // Updated evaluation bar function for vertical chess.com style
                       // Updated evaluation bar function for proper 50-50 split
window.updateEvalBar = function(value) {
    const evalWhite = document.getElementById('evalWhite');
    const evalBlack = document.getElementById('evalBlack');
    const evalValue = document.getElementById('evalValue');

    if (evalWhite && evalBlack && evalValue) {
        if (typeof value !== 'number' || isNaN(value)) {
            console.warn('⚠️ Invalid evaluation value:', value);
            evalValue.textContent = 'N/A';
            evalWhite.style.height = '50%';
            evalBlack.style.height = '50%';
            evalWhite.style.backgroundColor = '#ffffff';
            evalBlack.style.backgroundColor = '#333333';
            return;
        }

        // Convert evaluation to percentage (capped at +/-5)
        const cappedValue = Math.max(-5, Math.min(5, value));

        let whitePercentage, blackPercentage;

        if (cappedValue >= 0) {
            whitePercentage = 50 + (cappedValue / 5) * 40;
            blackPercentage = 100 - whitePercentage;
        } else {
            blackPercentage = 50 + (Math.abs(cappedValue) / 5) * 40;
            whitePercentage = 100 - blackPercentage;
        }

        evalBlack.style.height = blackPercentage + '%';
        evalWhite.style.height = whitePercentage + '%';

        evalWhite.textContent = '';
        evalBlack.textContent = '';

        evalValue.textContent = value >= 0 ? '+' + value.toFixed(1) : value.toFixed(1);

        if (value > 3) {
            evalWhite.style.backgroundColor = '#ffffff';
        } else if (value > 0.3) {
            evalWhite.style.backgroundColor = '#ffffff';
        } else {
            evalWhite.style.backgroundColor = '#737071';
        }

        if (value < -3) {
            evalBlack.style.backgroundColor = '#0d0c0d';
        } else if (value < -0.3) {
            evalBlack.style.backgroundColor = '#0d0c0d';
        } else {
            evalBlack.style.backgroundColor = '#402e36';
        }
    }
};



        function updateEvalBar(value) {
            window.updateEvalBar(value);
        }

        // Click outside modal to close
        window.onclick = function(event) {
            const modal = document.getElementById('gameOverModal');
            if (event.target === modal) {
                closeGameOverModal();
            }
        };
    </script>
</body>
</html>
